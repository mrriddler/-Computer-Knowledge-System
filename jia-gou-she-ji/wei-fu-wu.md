# 微服务

**从宏观功能的角度设立边界，聚合为服务，并从最高的边界级别物理隔离。这种隔离降低了系统整体的风险，也给了服务自身很高的自治性，服务可以自主把控技术栈、部署、扩容等，提高系统整体的灵活性，更好的适应未来的变化。**而自治也带来了挑战，通信、部署、容错、假面\(Facade\)、数据一致性、监控等都是要解决的问题。

解决这些问题统称为**服务治理**，服务治理的英文是governance，它不指代一项具体的技术，它泛指所有保证微服务长期在健康状态运作的技术。

从系统角度来讲，微服务划分大量的服务，是个标准的分布式系统。

## 服务通讯

微服务作为分布式系统，最基本的问题就是服务通讯。服务间通讯一般使用RPC，服务内通讯一般使用Message Queue。

## 服务部署

微服务划分后的每个服务都是独立的实体，部署会面临以下几个问题。

* 服务级别的部署、扩容。
* 服务异常不影响其他服务。
* 服务实例不影响其他服务实例\(可限制服务实例占用资源上限\)。
* 敏捷构建并部署。

**虚拟化**或**容器化**。**虚拟化解决的核心问题是资源调配，而容器化解决的核心问题是应用开发、测试和部署**。虚拟化设计上寄生、宿主内核，有更强的隔离性、更高的资源利用率、更强大的资源管理，但其构建速度过慢不适合敏捷部署。容器化设计上共享内核，简单易行，更适合敏捷部署。

### 服务注册与发现\(discovery\)

通常，服务会在虚拟化或容器化的环境下运行，服务实例的数量和物理地址会不断变化，这就需要**服务注册表**来记录服务实例的地址。对服务的请求，需要被路由到服务注册表，再进行**负载均衡**，最后落到服务实例上，这个过程就是**服务发现**。服务的上下线需要反映在服务注册表，这个过程就是服务注册。

### 配置

在微服务的部署灵活性下，配置管理这个问题的复杂度会被放大。配置不仅要做到版本隔离、环境隔离。还需要做到同一环境、版本下，部署的服务实例之间保持一致。

## 雪崩\(avalanche\)

提高分布式系统容错性的关键就是避免雪崩。**雪崩指的是系统出现局部问题，局部问题大量耗费总体资源，最终导致系统大面积不可用。**微服务将服务物理隔离开，通过网络通信构成大型的分布式系统。这样的系统中，错误不可避免，防止雪崩是微服务重要的一环。有以下几个法宝解决雪崩问题。

* 过载/限流：设置服务接入的最大QPS、连接数等，给个体一个占用资源维度的保护。
* 超时：针对服务设置超时时间，给个体占用资源一个时间上限。
* 熔断\(circuit breaker\)：熔断就是断路器模式，当服务错误数达到一个上线\(threshold\)，自动将请求回绝，剪掉链路，防止扩大问题的规模。当剪掉链路后，链路进入半打开阶段，若成功，则进入打开状态。若失败，则重新进入熔断状态。
* 降级\(degrade\)：为了防止被依赖服务拖垮，针对依赖服务设置特定的响应，当依赖服务出现问题，动态部署已设定的响应。

## 网关\(API Gateway\)

庞大的分布式系统为了隐藏系统内部构造，通常会有假面层\(Facade\)，微服务的假面层就是网关。**网关最主要解决的问题是帮助客户路由到对应的服务实例并访问。**客户不应该操心服务实例的物理地址或服务内部划分细节，所以抽象一层网关，将网关成为整体微服务系统的单一入口。网关主要的过程其实就是**服务发现**。伴随网关成为单一的入口，网关还可以提供更强大的能力。

* 协议转换：一般来讲，客户访问的协议与服务之间的协议不能限制为同一个，所以网关经常担任将客户访问协议转换为微服务内部协议的工作。
* 身份鉴权\(access token\)：在入口做安全预防，针对需要鉴权的服务，对其验证身份。
* 请求合并：为了减少连接占用数和通信消耗等资源，可将多个请求合并。

### Backends for frontends

网关还有一个变种BFF\(前端的后端\)，BFF既可以指在网关之前聚合一层或者是应对不用类型客户的网关层。BBF解决以下几个问题。

* 服务跨越：服务API与客户所需不匹配，导致客户一个需求需要请求多个服务。
* 多类型客户适配：Mobile、Web等不同类型客户有不同的需求、情况。

## 服务监控

对于任何系统，监控都是必要的。对于微服务来说，有以下几个关键点。

* 整条服务调用链路跟踪\(distributed tracing\)：微服务系统中通常包含大量服务，整条调用链路的监控，可以帮助调用者理清调用来源、依赖关系、调用瓶颈、快速定位异常。
* 度量\(Metrics\)：从多维度描述微服务状态的量化。换句话说，度量是一个如何采集、采集什么数据、如何表示采集数据的标准。其中包括针对服务实例的健康检查\(health check\)，健康检查保证服务实例处于可用状态。

## 集群

### 流量牵引

流量牵引指的是以一定的维度将流量调度到特定的集群上。

* 用户维度：以用户uid/vip区分流量。
* 环境维度：区分内测流量和对外流量。

## Service Mesh

Service Mesh\(网络网格\)是一个新想法，但没添加新的能力。由于服务通讯涉及服务发现、防止雪崩、监控等众多服务治理元素，Service Mesh在其上抽象了一层，并打入服务，随着服务一起部署，使整个网络拓扑结构去中心化，形成一个一个的格子，所以叫做网络网格。Service Mesh一般就是一组轻量级网络代理\(Sidecar proxy\)。

## 数据一致性

微服务给每个服务的自主性包括数据库的选型和使用，这给数据库架构添加了复杂度。其中一个必须要解决的问题就是数据一致性。

* 分布式事务：通过事务协调者，达到多节点一致性。
  * 2PC\(Two-Phase-Commit\)两阶段提交：整个过程分为两阶段，第一阶段投票，事务协调者向所有参与方询问是否能够进行成功，所有参与方投票后，事务协调者根据结果决定是否进入第二阶段，所有人同意后就进入第二阶段提交，执行事务提交。
  * TCC\(Try-Confirm-Cancel\)模式：TCC模式与2PC类似，每一参与方都约定好成功\(Confirm\)、失败\(Cancel\)场景的处理，所有参与方一同发起事务\(try\)，事务协调者收集所有参与方事务的结果来决定最终是一同成功还是一同失败。与2PC不同的是，事务协调者收集结果的时候，不会阻塞参与方做其他事情。
* 事件驱动：不通过任何协调者，发布/订阅事件达到事务的最终一致性。事件驱动一定要确保本地事务和发布事件两个操作的一同原子性。
  * 本地事务：为事件添加一张新表，发布事件通过向表插入数据再查询做到，这样发布事件相当于加入了本地事务。
  * 挖掘日志：数据库日志反映出数据的变化，通过挖掘日志发布事件。
  * 事件源：将保存业务实体改为添加一系列状态改变事件。

## 引用

[https://microservices.io/patterns/index.html](https://microservices.io/patterns/index.html)

[https://www.nginx.com/blog/building-microservices-inter-process-communication/](https://www.nginx.com/blog/building-microservices-inter-process-communication/)

[https://jimmysong.io/posts/what-is-a-service-mesh/](https://jimmysong.io/posts/what-is-a-service-mesh/)  


