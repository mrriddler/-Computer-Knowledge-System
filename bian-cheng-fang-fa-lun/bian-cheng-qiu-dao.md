# 编程求道

本篇深究抽象、编程语言、解释语言、程序、范式，这些内容大多是高屋建瓴的概念，需要像佛教、禅宗中的“悟”，只可意会不可言传，笔者尝试将这一探讨过程记录下来，汇聚成文，各位看官各取所需吧。

## 抽象

这一切要从抽象开始讲起，抽象是如此的自然，人类每时每刻都在运用，却难以察觉它的存在。实际上，当讲抽象这两个字时，都是在抽象在“抽象”它自己。当你用一个名字将一个事物联系起来，通过这个名字去指代事物的时候，你就遇到了抽象。**抽象做了两件事，将被抽象事物推向更广泛，使其可以指代越来越广泛的东西。抽象形成隔离，将被抽象事物对外隐藏。**

## 编程语言

这里为了“推演”，将过程定义为计算片段这一概念，一直提高过程的抽象层级、推向更广泛，来看看会发现什么。

首先举一个最简单的过程：

```text
{
  1;
}
```

这两个{}中间的1就可以被理解为一个最简单的过程。接下来提高抽象层级、推向更广泛，就可以得到if/else。if/else就是一个二分过程，这个过程对if语句后面的...进行抽象，推广到两种情况：

```text
if (...) {
  1;
} 
else {
  0;
}
```

再接着提高抽象层级、继续推向更广泛，就得到了函数，接受参数、返回值。函数对参数进行抽象，只要是符合参数要求的任意参数、任意多种情况都适用。相比于if/else将能指代范围上了个台阶。

```text
int func(int p, ...) 
{
  return 1;
}
```

再将函数提高抽象层级、继续推向更广泛，就得到了参数、返回可以为函数的函数。相比于只接受、只返回数据类型值的函数，其能指代的东西更加广泛了。

```text
func func(func f, ...) 
{
  return f;
}
```

如果持续提高、推向更广泛会得到什么？一个框架、一种架构、一门语言。

**反思此推演：**

函数指的是抽象本身？真正抽象是人脑而不是函数本身，函数是提供给抽象的一种方法。最后推广到语言，过程不再局限于两种情况、不再局限于某种特定的行为。一门语言与if/else有本质区别吗？实际上是没有的，只是提供的抽象层次不同、指代的范围不同。

### 语言的三大要素

* 基本\(primitive\)表达式\(expression and statements\)：语言提供的最基本元素。
* 组合\(combination\)的方法：语言提供的能将基本元素组合的能力。
* 抽象\(abstraction\)的方法：对某个表达式或组合后的表达式命名，将表达式或组合后表达式与名字捆绑起来，让表达式或组合后的表达式可以通过捆绑的名字被单独隔离出来当做一个单独的个体使用。

从构成上看，语言由基本元素和复合元素构成，类似Component模式。语言通过不断添加可用于表达抽象元素而慢慢壮大，这也就是说，**任何语言都是由表达抽象的基本元素和能够将基本元素组合的能力构成的**。

### 特性

探讨了这么多，编程语言能够一通百通的原因已经渐渐浮出水面了。编程语言既然都是由表达抽象的基础元素构成的，那么不同的编程语言只是表达不同，能够对如何抽象运用得当并精通一种表达，其他表达学习起来自然轻车熟路。这里，必须提一下[王垠的一篇关于语言的文章](http://www.yinwang.org/blog-cn/2017/07/06/master-pl)，文中强调了语言最关键的就是--特性。这实际上，是另一种解读，从语言使用者的视角来看，基本元素先构成了特性，而再由语法特性构成了语言。

## 解释语言

如果说程序真正的作用不在抽象，那程序的核心是？程序真正的核心在于解释语言，即如何对输入求值。

解释语言很容易让人想起解释器，而这句话不仅仅光指解释器，任意程序都是将“输入”看做语言，并解释他们。程序的任务是对输入求值这好理解，而真正要理解程序的核心是解释语言，有个等价关系要理解，对于计算机，语言即数据。JSON就是最标准的语言即数据。实际上对于计算机来说，**解释就是寻觅蕴藏在语言中的数据并对其进行求值**。

### 求值模型

解释最核心的就是求值器和求值模型。求值有两种模型：

* 代换模型
* 环境模型

代换模型是一个相对简单的模型，将求值过程看做数学函数代换，应用过程时，将过程名直接带换成过程体，然后将形参带换成入参。这个求值模型，简直就是在让计算机做算术题。

然而，这个近数学的求值模型有个很大的弊端。不可以改变已定义变量的值，便有了第二个模型。

环境模型是语言真正使用的模型。求值实际上在求当前环境下该值的约束值。环境可以认为是一序列frame，当前环境就是当前frame，frame就是该环境下所有值和其约束值的表格。环境随着语言的解释可以在序列上切换，而何时切换，要看语言使用的作用域\(块级作用域等\)。函数栈就是环境这个抽象概念的实现。

### 时间

环境模型与代换模型最大的不同就是环境模型引入了时间，**变量值的改变即状态改变隐式的反映出时间的流逝**。

然而这两种模型都有各自的缺点。

> 本章开始时提出了一个目标，那就是构造出一些计算模型，使其结构能够符合我们对于试图去模拟的真实世界的看法。我们可以将这一世界模拟为一集相互分离的、受时间约束的、具有状态的相互交流的对象，或者可以将它模拟为单一的、无时间也无状态的统一体。每种观点都有其强有力的优势，但就其自身而言，又没有一种方式能够让人们完全满意。我们还在等待着一个大一统的出现。
>
> — SICP第三章最后一段

### lambda表达式

lambda表达式是过程的数学表达，而计算机表达就是函数或方法。之所以要在求值模型中提到lambda，是因为lambda不完全的定义就是：lambda表达式正文和其被定义时的外部环境。这也就是说lambda的环境会被拓展\(extend\)到被定义的环境。函数如此，方法更如此，方法的环境可以看做被拓展到被定义的类\(class\)中。而这就叫做**词法作用域\(lexical scope\)**或者**静态作用域**。拓展到运行时的环境，叫做**动态作用域**。

### 闭包\(closure\)

闭包可以看做是在lambda中定义另一个lambda的指代。这个闭包的名字是怎么由来的呢？这是因为这个新定义的lambda通过读、写和被定义时环境的数据形成了一个闭环，所以叫做闭包。实际上还可以得出closure依赖于词法作用域。

### 求值器\(evaluator\)

求值器的理论基础基于环境求值模型求值，这其中，只牵扯到两个步骤：在当前环境求值和切换环境求值。

* 当前环境：在当前环境，直接求值的约束值。
* 切换环境：若要切换环境，就要伴随着传入参数。将参数应用到新环境，在新环境中继续步骤一。

这就是著名的**eval-apply循环**。

将参数应用到新环境有两种变种：

* 应用序：在将参数应用的时候，就将所有参数完成求值。
* 正则序：等到真正需要参数的时候再完成求值。

thunk\(盒子\)是将应用序转化为正则序的术语，形象的描述就是将变量盖上个盒，应用的时候，如果是有盒子盖上的话就不求值，等到真正使用的时候，再强迫\(force\)翻开盒子，然后求值。

在环境求值模型下，thunk的不完全定义就是表达式和其环境。

而在一个环境内部进行求值还有两种变种：

* 顺序求值：进入环境后，顺序求所有值。
* 变量提升：进入环境后，在求任何值之前，建立所有局部变量。

## 范式

在“推演”了一番编程语言、解释语言后，本章来“推演”与编程语言与千丝万缕关系的范式。

### 面向对象编程\(object-oriented-programming\)

从物理经典力学的角度来看世界，世界由两种元素构成，物体和力，不是物体向其他物体施力，就是物体受力。面向对象编程的世界观与其类似，对现实世界的模型系统进行抽象，一切可以抽象成对象，但不仅仅是这样，一切可以抽象为对象的状态和对象的行为，状态就对应着物体，而行为对应着力。**不是对象中的状态出现行为，就是行为作用于对象的状态。对象中的状态通过行为互相联系起来，构成这个不再孤单的世界。面向对象编程的核心就在于对象中的状态\(status\)和对象具有的行为\(behivahor\)。**

**特征**

面向对象编程的特征有三个：封装\(encapsulation\)、继承\(inheritance\)、多态\(polymorphism\)。封装为抽象提供了对外的隐藏、隔离。继承、多态组合起来为抽象提供了推向更广泛的能力，继承体行为即可以和被继承体一致，也可以通过覆写\(override\)表现出自己的行为，推广出更多独特的行为。

### **基于类和基于原型\(base on class or prototype\)**

面向对象编程有两个较出名的编程模型，一个是基于原型，一个是基于类。

基于原型与基于类一个重要的区分就是：静态和动态。静态指的是，在编译时确定对象的状态和行为，形成编程者之间的“约定”。而动态没有这样的“约定”，在运行时再确定对象的状态和行为。同样是面向对象编程，但区分出了两种编程模型。

而没有了这样的“约定”，也就没有检查这些“约定”的必要。伴随基于原型的常常是解释型、弱类型。

**消息\(message\)**

Objective-C、Ruby、Java、Python等面向对象编程语言中，其对象调用方法，实际上是给对象发消息。而C++面向对象编程则不同。这些编程语言对面向对象编程的核心主张没有什么不同，同样是对象和对象具有的行为。不同在于是对象固有行为，还是行为绑定到对象身上。绑定到对象身上代表可以随时解绑和绑定，固有则不可以修改。

### 泛型编程\(generics\)

泛型是一种主范式的补充\(complementary\)范式，对类型做抽象，解决由于类型带来的代码复用问题、加强类型安全、减少类型转换等问题。诞生之初，泛型是个对OOP的补充\(complementary\)。这个补充主要指的是如果用OOP的继承解决复用问题，会导致很明显的问题，完全违反了组合优于继承的设计原则，所以泛型代替继承去解决复用问题。从泛型能做的事或者说能解决问题的角度来看，泛型不是主范式的料，也就作为为主范式的补充范式。

**多态**

泛型编程与面向对象编程的特征多态本意是一样的，都是根据不同的类型表现出不同的“形状\(shape\)”。所以泛型编程又叫做参数化类型\(parameterized type\)或者参数化多态\(parametric polymorphism\)。而相对于面向对象编程运行时确定类型，泛型中的参数化类型都是在编译期确定的，所以泛型编程又叫做编译时多态，面向对象编程的特征多态又叫做运行时多态。

而从接口的角度讲，面向对象编程多态在运行时才确定不同的类型表现出的形状，这就称之为动态绑定\(dynamic binding\)。

### 面向协议编程\(protocol-oriented-programming\)

面向协议编程是Swift的革命口号。**面向协议编程的世界观：一切都是性质构成的主体，性质可以构成复合性质，而由性质构成主体，主体具有状态和行为，状态通过行为联系起来，构成整个世界**。面向对象编程更像是面向名词抽象，而面向协议编程更像是面向形容词抽象。

### 函数式编程\(functional programming\)

**函数式编程的世界观：一切皆是数学函数，只要参数一致，结果一致的数学函数**。而在数学函数的世界中，不存在时间这一维度。函数式编程相较于环境模型，更偏向代换模型。

### 响应式编程\(functional-reactive-programming\)

响应式编程是子范式，其世界观继承函数式编程。**世界不存在时间这一维度，物体不存在变化，只会产生新物体，而新物体的产生又有关联效应，新物体的产生和关联效应构成了这个世界**。响应式编程所讲的哲学一切皆是流，便是如此了。

### 方法论

“推演”过面向对象编程、泛型编程、面向协议编程、函数式编程、响应式编程后这几个范式后，范式共通的一面、独特的一面也被揭开了神秘的面纱。范式是在提供一种抽象的方法论，不同的范式只不过是世界观不同而导致方法论不同。

## 总结

总结一句话：编程就是抽象，编程语言提供一种抽象的表达，也就是作为抽象的工具，好的编程者抽象的更加明确、融洽，对抽象的表达更加清晰。范式是在提供一种抽象的方法论，不同的范式只不过是世界观不同而导致方法论不同。程序真正所做的就是解释语言，即寻觅蕴藏在语言中的数据，并对其进行求值。

## 引用

计算机程序的构造和解释\(SICP\)--原书第二版

